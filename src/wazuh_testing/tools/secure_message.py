import hashlib
import zlib

from Crypto.Cipher import AES, Blowfish
from Crypto.Util.Padding import pad
from typing import Union, Literal, Tuple


class SecureMessage:
    """Class to handle the manager-agent secure messages:
    https://documentation.wazuh.com/current/development/message-format.html#secure-message-format.
    """
    __block_size = 16
    __aes_iv = b'FEDCBA0987654321'
    __blowfish_iv = b'\xfe\xdc\xba\x98\x76\x54\x32\x10'

    algorithm_headers = {'AES': b'#AES:', 'BLOWFISH': b':'}

    @classmethod
    def encrypt(cls, message: bytes, key: bytes, algorithm: str) -> bytes:
        algorithm = cls.__validate_algorithm(algorithm)
        cipher, data = cls.__get_cipher_and_data(message, key, algorithm)

        return cipher.encrypt(data)

    @classmethod
    def decrypt(cls, message: bytes, key: bytes,  algorithm: str) -> bytes:
        algorithm = cls.__validate_algorithm(algorithm)
        cipher, data = cls.__get_cipher_and_data(message, key, algorithm)

        return cipher.decrypt(data)

    @staticmethod
    def decode(message: bytes) -> str:
        padding = next((index for index, char in enumerate(
                        message) if char != 33), len(message))

        msg_remove_padding = message[padding:]
        msg_decompress = zlib.decompress(msg_remove_padding)

        return msg_decompress.decode('ISO-8859-1')

    @staticmethod
    def encode(message: bytes) -> str:
        # Compose sec message
        payload = b'55555' + b'1234567891' + b':' + b'0227' + b':' + message
        message_hash = hashlib.md5(payload).hexdigest()
        payload = message_hash.encode() + payload
        # Compress
        payload = zlib.compress(payload)
        # Padding
        padding = (b'!' * (8 - extra if (extra := len(payload) % 8) > 0 else 8))

        return padding + payload

    @classmethod
    def get_algorithm(cls, message: bytes) -> Union[str, None]:
        if cls.algorithm_headers['AES'] in message:
            return 'AES'
        elif cls.algorithm_headers['BLOWFISH'] in message:
            return 'BLOWFISH'

    @staticmethod
    def get_agent_id(message: bytes) -> Union[str, None]:
        """
        Extracts the agent ID from a given Wazuh message.

        In Wazuh, the agent ID is sent within the message, enclosed between 
        two exclamation marks '!'. Example: !001!: RestOfTheMsg...

        Args:
            message (bytes): The message from which to extract the agent ID.

        Returns:
            Union[str, None]: The ID as a string if it comes on the message. Otherwise None.
        """
        if not b'!' in message:
            return None

        # Get the agent ID from the message. Example: !001!
        start_index = message.find(b'!') + 1
        end_index = message.find(b'!', start_index)

        return message[start_index: end_index].decode()

    @classmethod
    def get_payload(cls, message: bytes, algorithm: str) -> bytes:
        """
        Extracts the payload and encryption algorithm from a given wazuh message.

        Args:
            message (bytes): The message from which to extract the payload and encryption algorithm.

        Returns:
            bytes: The extracted payload.

        Raises:
            ValueError: If the message encryption header is invalid.
        """
        algorithm = cls.__validate_algorithm(algorithm)

        if algorithm == 'AES':
            start_index = message.find(cls.algorithm_headers['AES'])
            end_index = start_index + 5
        elif algorithm == 'BLOWFISH':
            start_index = message.find(cls.algorithm_headers['BLOWFISH'])
            end_index = start_index + 1

        if start_index == -1:
            raise ValueError('Invalid message encryption header.')

        return message[end_index:]

    @staticmethod
    def get_encryption_key(id: str, name: str, key: str) -> bytes:
        """Generate an encryption key using agent metadata and a key.

        The encryption key is generated by combining the MD5 hashes of the agent name,
        agent ID, and the provided key.

        Args:
            id (str): The ID of the agent.
            name (str): The name of the agent.
            key (str): The encryption key.

        Returns:
            bytes: The generated encryption key as bytes.
        """
        first_hash = (hashlib.md5(hashlib.md5(name.encode()).hexdigest().encode() +
                                  hashlib.md5(id.encode()).hexdigest().encode()
                                  ).hexdigest().encode())[:15]
        second_hash = hashlib.md5(key.encode()).hexdigest().encode()

        return second_hash + first_hash

    @classmethod
    def set_algorithm_header(cls, message: bytes, algorithm: str) -> bytes:
        """
        Extracts the payload and encryption algorithm from a given wazuh message.

        Args:
            message (bytes): The message from which to extract the payload and encryption algorithm.

        Returns:
            Tuple[bytes, str]: The extracted payload and encryption algorithm.

        Raises:
            ValueError: If the message encryption header is invalid.
        """
        algorithm = cls.__validate_algorithm(algorithm)
        header = cls.algorithm_headers[algorithm]

        return header + message

    @classmethod
    def __get_cipher_and_data(cls, payload: bytes, key: bytes,
                              algorithm: Literal['AES', 'BLOWFISH']) -> Union[object, bytes]:
        if algorithm not in cls.algorithm_headers.keys():
            raise ValueError(f'Invalid encryption/decryption algorithm.')

        if algorithm == 'AES':
            cipher = AES.new(key[:32], AES.MODE_CBC, cls.__aes_iv)
            payload = pad(payload, cls.__block_size)
        elif algorithm == 'BLOWFISH':
            cipher = Blowfish.new(key, Blowfish.MODE_CBC, cls.__blowfish_iv)

        return cipher, payload

    @classmethod
    def __validate_algorithm(cls, algorithm: str) -> str:
        if not algorithm or algorithm.upper() not in cls.algorithm_headers.keys():
            raise ValueError('Invalid encryption algorithm.')

        return algorithm.upper()
